# 5장 

## ****\*\*\*\*****객체 지향(Objected - Oriented)의 본질은 무엇인가?****\*\*\*\*****

### 캡슐화?

객체 지향 언어는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공한다.

이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 **서로 구분 짓는 선**을 그을 수 있다.

구분선 바깐에서 데이터는 은닉되고, 일부 함수만이 노출된다.

c언어에서도 데이터 구조와 함수를 헤더파일(노출부)에 선언하고, 구현 파일(은닉부)에서 구현하는 방식으로 캡슐화를 지킬 수 있다.

### 상속화?

객체 지향 언어는 캡슐화를 강제하지 않지만, 상속은 확실히 제공한다.

C언어에서는 상속을 흉내낼 수 있을 뿐, 상속의 기능을 제공하진 않았따.

### 다형성?

다형성은 기존에 존재하던 함수 포인터를 응용한 것이다.

다형성의 매력은 , 의존성을 낮추고 재활용성을 높여 하나의 기능을 여러 프로그램이 활용할 때

수정이 필요없이, 플러그인처럼 사용 가능하게 하는 것이다.

### 의존성 역전

[##_Image|kage@US5y4/btsqJB8PDre/PK5zRqLM5p8MlNMCUEX4kk/img.png|CDM|1.3|{"originWidth":1392,"originHeight":736,"style":"alignCenter"}_##]

기존의 소스코드 의존성의 경우, 제어흐름과 동일하게 결정된다.

하지만 다형성을 활용한다면, 소스 코드 의존성의 방향을 스스로 제어할 수 있게된다.

[##_Image|kage@dw5MNv/btsqLw6Izcd/mH2NTYAmkklNoYkRc6Dv7k/img.png|CDM|1.3|{"originWidth":696,"originHeight":346,"style":"alignCenter"}_##]

인터페이스를 활용하여 의존성을 역전시킨 예시

### 궁극적으로 만들고자 하는 형태

[##_Image|kage@wSHvc/btsqRfiPewK/Cn1Fw2bKwUaGrksg7wCKRK/img.png|CDM|1.3|{"originWidth":694,"originHeight":170,"style":"alignCenter"}_##]

위 그림을 보면, 비즈니스 룰은 제어흐름에 따라 데이터베이스와 UI를 사용하지만, 의존하지 않는다. 그렇기에 비즈니스 룰은 UI와 데이터베이스와는 독립적으로 배포가 가능하다.

즉 세가지 컴포넌트들은 모두 개별적이고, 독립적으로 배포가 가능하다.

따라서 프로그램은 **배포 독립성**을 가지게 되고, 각 팀에서 각 모듈을 독립적으로 개발하여 **개발 독립성**을 얻을 수 있다.
