# 12장 컴포넌트

## 컴포넌트

> SOLID는 벽과 방에 벽돌을 배치하는 방법
컴포넌트 - 빌딩에 방을 배치하는 방법
- 시스템이 배포할 수 있는 가장 작은 단위 (자바의 jar파일)
- 여러 컴포넌트들을 링크하여 실행 가능한 단일 파일로 생성 가능하고 독립적 배포도 가능
- 잘 설계된 컴포넌트는 독립적으로 배포 가능한, 개발 가능한 능력을 갖춰야 한다.

## 컴포넌트의 역사

- 프로그래머가 메모리에서의 프로그램 위치와 레이아웃을 직접 설정
- 라이브러리는 소스 코드 형태로 유지되어 컴파일시 애플리케이션 코드에 포함시켜서 단일 프로그램으로 컴파일
    - 메모리가 작아서 컴파일러는 느린 장치를 이용해 소스 코드를 여러차레 컴파일
    - 프로그램이 커질수록 컴파일이 오래 걸림
- 함수 라이브러리 소스 코드를 애플리케이션 코드와 분리
    - 라이브러리를 개별 컴파일하고 메모리 특정 위치에 로드
    - 라이브러리가 로드된 후 애플리케이션을 로드
    - 애플리케이션이 커지면서 함수 라이브러리 공간을 사이에 두고 애플리케이션 코드가 두 세그먼트로 분리되어 배치
        - 함수 라이브러리 공간이 커지면 라이브러리 자체도 세그먼트로 분리해야 함

## 재배치성

- 재배치가 가능한 바이너리가 해결책
- 로더는 재배치 코드가 자리할 위치 정보를 전달받음
    - 재배치 코드에는 로드한 데이터에서 어떤 부분을 수정해야 정해진 주소에서 로드할 수 있는지 알려주는 플래그가 삽입 (보통 메모리 시작 주소)
- 컴파일러는 재배치 가능한 바이너리 안 함수 이름을 메타데이터 형태로 생성하도록 수정
    - 라이브러리 함수 이름을 외부 참조로 생성
    - 라이브러리 정의 프로그램이라면 외부 정의로 생성
    - 외부 정의 로드 위치가 정해지면 로더가 외부 참조를 외부 정의에 링크시킬 수 있음
    - 링킹 로더의 탄생

## 링커

- 링킹 로더 덕분에 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 됨
- 프로그램이 커지면서 링킹 로더가 너무 느려져 로드와 링크가 두 단계로 분리
- 링크는 링커라는 별로 애플리에이션이 처리 → 로드가 빨라짐
- 머피의 법칙
    - 컴파일하고 링크하는 데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다
    - 로드는 빨라졌지만 컴파일 - 링크의 병목 구간

- 무어의 등장
    - 디스크가 빨라지고 메모리는 커지고 클럭 속도는 빨라졌다.
    - 프로그램이 커지는 속도보다 링크 속도가 더 빨라짐
    - 링크-로더 동시에 하는 게 가능해짐 → 컴포넌트 플러그인 아키텍처가 탄생

## 결론

- 동적 링크 파일 = 소프트웨어 컴포넌트
